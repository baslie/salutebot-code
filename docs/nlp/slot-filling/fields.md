---
title: Заполнение слотов из запроса в Code и Brain
source_url: https://developers.sber.ru/docs/ru/va/code/nlp/slot-filling/fields
description: Документация для разработчиков | Разработка приложений для виртуального
  ассистента Салют
reading_time: 1
badges:
- Code
- Brain
breadcrumbs:
- Заполнение слотов из запроса
toc:
- title: АтрибутТип
  level: 2
  id: atribut-tip2
- title: АтрибутОбязательность
  level: 2
  id: atribut-obyazatelnost2
- title: Массивы в слотах
  level: 2
  id: massivy-v-slotah2
---

<!-- Бейджи: Code | Brain -->

# Заполнение слотов из запроса в Code и Brain

Содержание раздела

* [Атрибут Тип](#атрибуттип)
* [Атрибут Обязательность](#атрибутобязательность)
* [Массивы в слотах](#массивы-в-слотах)

# Заполнение слотов из запроса в Code и Brain

Обновлено 28 декабря 2023

[![](/assets/nlp/slot-filling/fields/Code.png)
Code](../../overview.md)[![](/assets/nlp/slot-filling/fields/Brain.png)
Brain](../overview.md)

Если рассматривать [`интент`](../../sa-dsl/tags/intents-tags.md) как функцию, которую пользователь может вызвать, то `слот` является переменной, параметром этой функции.

Например, для интента `/Погода` примером фразы может быть «Погода в Лондоне сегодня» и два слота `City` и `Date`.
В этом случае в слот `City` попадет — Лондон, а в слот `Date` — сегодня.

При этом заполненные слоты будут переданы в сценарий в переменной `$parseTree._<ИмяСлота>`. В значении переменной будет ассоциированное значение, при его отсутствии — текст.

Использование заполненных слотов в сценарии:

```
state:
    intent!: /Погода
    a: Погода в {{ $parseTree._City }} на {{ $parseTree._Date }}
```

[Подробнее о заполнении слотов в интерфейсе Code](https://developers.sber.ru/docs/ru/va/chat/voice-interface/command-recognition/intents#zapolnenie-slotov-dlya-intenta2).

## Атрибут `Тип`

Каждый слот должен иметь `Тип`, который соответствует сущности `Тип = сущность`. Этот тип определяет тип данных, которые попадут в слот. Вы можете использовать как [системные, так и собственные сущности](../entities/overview.md).

Например, для слота `Date` с типом `@zb.datetime`: слово «сегодня» из запроса клиента попадет в сущность `@zb.datetime` и будет помещено в слот `Date`.

Если в интенте присутствует несколько слотов с одинаковым типом, то они будут заполнены последовательно.

Если нужно обработать произвольное количество слотов одного типа в запросе или переменные с разными типами сущностей, обращайтесь к переменной [`$entities`](https://developers.sber.ru/docs/ru/va/chat/voice-interface/command-recognition/entities/entities-usage), которая содержит все найденные сущности в исходном виде.

## Атрибут `Обязательность`

Каждый слот имеет атрибут `Обязательность`:

* Если слот обязателен и при этом уточняющие вопросы не указаны, то заполнение слота в ответе обязательно для срабатывания интента.
* Если слот обязателен и при этом уточняющие вопросы указаны, то интент сработает и без этого слота. Интент будет обработан модулем слот-филлинга, пользователю будут заданы уточняющие вопросы.

Перед работой со слот-филлингом ознакомьтесь с [заполнением слотов](https://developers.sber.ru/docs/ru/va/chat/voice-interface/command-recognition/intents#zapolnenie-slotov-dlya-intenta2).

## Массивы в слотах

Для обработки запросов с повторяющимися сущностями в сценарии слот `$parseTree._<ИмяСлота>` должен содержать массив.

Включите опцию **Массив**, чтобы в слот помещались все сущности данного типа, оформленные как массив:

![массивы в слотах](/assets/nlp/slot-filling/fields/fields-2d728578da45957fa0d0ef39c13b0656.png)

Если опция **Массив**:

* **Не активна**: в слот помещается первое обработанное значение данной сущности.
* **Активна**: в слот помещаются все сущности данного типа, оформленные как массив. Если обнаружено только одно значение сущности, оно также оформляется как массив.

Заметили ошибку?

Выделите текст и нажмите `Ctrl` + `Enter`, чтобы сообщить нам о ней